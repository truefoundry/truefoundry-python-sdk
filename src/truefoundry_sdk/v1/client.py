# This file was auto-generated by Fern from our API Definition.

import typing
from ..core.client_wrapper import SyncClientWrapper
from .artifacts.client import ArtifactsClient
from .agents.client import AgentsClient
from .prompts.client import PromptsClient
from .tools.client import ToolsClient
from .models.client import ModelsClient
from .artifact_versions.client import ArtifactVersionsClient
from .model_versions.client import ModelVersionsClient
from .prompt_versions.client import PromptVersionsClient
from .tool_versions.client import ToolVersionsClient
from .agent_versions.client import AgentVersionsClient
from .data_directories.client import DataDirectoriesClient
from .ml_repos.client import MlReposClient
from ..types.manifest import Manifest
from ..core.request_options import RequestOptions
from ..types.apply_response import ApplyResponse
from ..core.serialization import convert_and_respect_annotation_metadata
from ..core.pydantic_utilities import parse_obj_as
from ..errors.unprocessable_entity_error import UnprocessableEntityError
from ..types.http_validation_error import HttpValidationError
from json.decoder import JSONDecodeError
from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper
from .artifacts.client import AsyncArtifactsClient
from .agents.client import AsyncAgentsClient
from .prompts.client import AsyncPromptsClient
from .tools.client import AsyncToolsClient
from .models.client import AsyncModelsClient
from .artifact_versions.client import AsyncArtifactVersionsClient
from .model_versions.client import AsyncModelVersionsClient
from .prompt_versions.client import AsyncPromptVersionsClient
from .tool_versions.client import AsyncToolVersionsClient
from .agent_versions.client import AsyncAgentVersionsClient
from .data_directories.client import AsyncDataDirectoriesClient
from .ml_repos.client import AsyncMlReposClient

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class V1Client:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper
        self.artifacts = ArtifactsClient(client_wrapper=self._client_wrapper)
        self.agents = AgentsClient(client_wrapper=self._client_wrapper)
        self.prompts = PromptsClient(client_wrapper=self._client_wrapper)
        self.tools = ToolsClient(client_wrapper=self._client_wrapper)
        self.models = ModelsClient(client_wrapper=self._client_wrapper)
        self.artifact_versions = ArtifactVersionsClient(client_wrapper=self._client_wrapper)
        self.model_versions = ModelVersionsClient(client_wrapper=self._client_wrapper)
        self.prompt_versions = PromptVersionsClient(client_wrapper=self._client_wrapper)
        self.tool_versions = ToolVersionsClient(client_wrapper=self._client_wrapper)
        self.agent_versions = AgentVersionsClient(client_wrapper=self._client_wrapper)
        self.data_directories = DataDirectoriesClient(client_wrapper=self._client_wrapper)
        self.ml_repos = MlReposClient(client_wrapper=self._client_wrapper)

    def apply(self, *, manifest: Manifest, request_options: typing.Optional[RequestOptions] = None) -> ApplyResponse:
        """
        Parameters
        ----------
        manifest : Manifest

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ApplyResponse
            Successful Response

        Examples
        --------
        from truefoundry_sdk import Model, TrueFoundry, TrueFoundryManagedSource

        client = TrueFoundry(
            api_key="YOUR_API_KEY",
            base_url="https://yourhost.com/path/to/api",
        )
        client.v1.apply(
            manifest=Model(
                metadata={"key": "value"},
                source=TrueFoundryManagedSource(),
            ),
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/ml/v1/apply",
            method="PUT",
            json={
                "manifest": convert_and_respect_annotation_metadata(
                    object_=manifest, annotation=Manifest, direction="write"
                ),
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    ApplyResponse,
                    parse_obj_as(
                        type_=ApplyResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncV1Client:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper
        self.artifacts = AsyncArtifactsClient(client_wrapper=self._client_wrapper)
        self.agents = AsyncAgentsClient(client_wrapper=self._client_wrapper)
        self.prompts = AsyncPromptsClient(client_wrapper=self._client_wrapper)
        self.tools = AsyncToolsClient(client_wrapper=self._client_wrapper)
        self.models = AsyncModelsClient(client_wrapper=self._client_wrapper)
        self.artifact_versions = AsyncArtifactVersionsClient(client_wrapper=self._client_wrapper)
        self.model_versions = AsyncModelVersionsClient(client_wrapper=self._client_wrapper)
        self.prompt_versions = AsyncPromptVersionsClient(client_wrapper=self._client_wrapper)
        self.tool_versions = AsyncToolVersionsClient(client_wrapper=self._client_wrapper)
        self.agent_versions = AsyncAgentVersionsClient(client_wrapper=self._client_wrapper)
        self.data_directories = AsyncDataDirectoriesClient(client_wrapper=self._client_wrapper)
        self.ml_repos = AsyncMlReposClient(client_wrapper=self._client_wrapper)

    async def apply(
        self, *, manifest: Manifest, request_options: typing.Optional[RequestOptions] = None
    ) -> ApplyResponse:
        """
        Parameters
        ----------
        manifest : Manifest

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ApplyResponse
            Successful Response

        Examples
        --------
        import asyncio

        from truefoundry_sdk import AsyncTrueFoundry, Model, TrueFoundryManagedSource

        client = AsyncTrueFoundry(
            api_key="YOUR_API_KEY",
            base_url="https://yourhost.com/path/to/api",
        )


        async def main() -> None:
            await client.v1.apply(
                manifest=Model(
                    metadata={"key": "value"},
                    source=TrueFoundryManagedSource(),
                ),
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/ml/v1/apply",
            method="PUT",
            json={
                "manifest": convert_and_respect_annotation_metadata(
                    object_=manifest, annotation=Manifest, direction="write"
                ),
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    ApplyResponse,
                    parse_obj_as(
                        type_=ApplyResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
